<section id="visitor_pattern">
    <h1>Visitor Pattern</h1>

    <h2>1. Introduction & History</h2>
    <p>
        The <b>Visitor Pattern</b> is a <i>behavioral design pattern</i> that lets you separate algorithms from the
        objects on which they operate.
        Instead of embedding operations inside the object itself, you "visit" the object with a separate class that
        contains the operation.
    </p>
    <p>
        It was first popularized in the <b>Gang of Four (GoF)</b> design patterns book (1994). It is especially useful
        when you need to perform many unrelated operations across a set of structured objects.
    </p>

    <h2>2. Real-Life Analogy</h2>
    <p>
        Imagine a <b>tax inspector</b> visiting different types of businesses (shops, factories, software companies).
        Instead of each business knowing how tax works, the inspector applies their rules to each business type.
        That’s the Visitor Pattern — the inspector (visitor) applies operations, and businesses (elements) accept them.
    </p>

    <h2>3. Structure Diagram (ASCII)</h2>
    <pre>
  +----------------+        +------------------+
  |   Visitor      |        |   Element        |
  |  visit(A)      |<----->|  accept(visitor) |
  |  visit(B)      |        |                  |
  +----------------+        +------------------+
          ^                          ^
          |                          |
  +----------------+        +------------------+
  | ConcreteVisitor|        | ConcreteElement  |
  +----------------+        +------------------+
  </pre>

    <h2>4. Java Code Example</h2>
    <pre>
// Visitor interface
interface Visitor {
    void visit(Book book);
    void visit(Fruit fruit);
}

// Element interface
interface Item {
    void accept(Visitor visitor);
}

// Concrete Element: Book
class Book implements Item {
    String title;
    double price;
    Book(String title, double price) {
        this.title = title; this.price = price;
    }
    public void accept(Visitor visitor) {
        visitor.visit(this); // delegate to visitor
    }
}

// Concrete Element: Fruit
class Fruit implements Item {
    String name;
    double weight;
    double pricePerKg;
    Fruit(String name, double weight, double pricePerKg) {
        this.name = name; this.weight = weight; this.pricePerKg = pricePerKg;
    }
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}

// Concrete Visitor: Price Calculator
class PriceVisitor implements Visitor {
    public void visit(Book book) {
        System.out.println("Book: " + book.title + " costs $" + book.price);
    }
    public void visit(Fruit fruit) {
        double cost = fruit.weight * fruit.pricePerKg;
        System.out.println(fruit.name + " costs $" + cost);
    }
}

// Demo
public class VisitorPatternDemo {
    public static void main(String[] args) {
        Item[] items = {
            new Book("Java Design Patterns", 50),
            new Fruit("Apple", 2, 3)
        };

        Visitor visitor = new PriceVisitor();
        for (Item item : items) {
            item.accept(visitor);
        }
    }
}
  </pre>

    <h2>5. Advantages</h2>
    <ul>
        <li>Separation of concerns — operations are decoupled from objects.</li>
        <li>Easy to add new operations (just add new Visitor).</li>
        <li>Encourages open/closed principle (open for extension, closed for modification).</li>
    </ul>

    <h2>6. Disadvantages</h2>
    <ul>
        <li>Adding new element types is hard (must update all visitors).</li>
        <li>Can lead to tight coupling between Visitor and Element hierarchy.</li>
    </ul>

    <h2>7. Real-world Uses</h2>
    <ul>
        <li><b>Compilers</b> – syntax tree visitors for type checking or optimization.</li>
        <li><b>Document processing</b> – different export operations (PDF, HTML, XML).</li>
        <li><b>IDE tools</b> – code inspection or refactoring visitors.</li>
    </ul>

    <h2>8. Variants & Alternatives</h2>
    <ul>
        <li><b>Double Dispatch Visitor</b> – ensures both element and visitor types determine behavior.</li>
        <li><b>Reflective Visitor</b> – uses reflection to avoid many `visit()` methods, but slower.</li>
        <li><b>Alternative:</b> Strategy Pattern can sometimes replace Visitor when you only need to swap algorithms.
        </li>
    </ul>

    <h2>9. Interview Questions</h2>
    <div class="interview">
        <ul>
            <li>What problem does the Visitor Pattern solve?</li>
            <li>Difference between Visitor and Strategy patterns?</li>
            <li>When should you avoid Visitor Pattern?</li>
            <li>Explain double dispatch in the context of Visitor.</li>
            <li>Give real-world systems where Visitor is heavily used.</li>
        </ul>
    </div>

    <h2>10. Notes for Keywords</h2>
    <div class="note">
        <p><b>Interface:</b> A contract that classes must implement.</p>
        <p><b>Accept:</b> A method in element that hands control to visitor.</p>
        <p><b>Double Dispatch:</b> Technique where method execution depends on both visitor type and element type.</p>
    </div>

    <h2>11. Developer Tips</h2>
    <div class="tips">
        <ul>
            <li>Use Visitor when your object structure is stable but operations change often.</li>
            <li>Avoid it if you expect frequent changes in object types — maintenance becomes painful.</li>
            <li>Combine with Composite pattern for traversing tree-like structures.</li>
            <li>Keep visitors cohesive — don’t overload them with unrelated logic.</li>
        </ul>
    </div>
</section>